# Объяснение

Это ядро — «сердце» реактивной системы. Здесь рождаются сигналы, вычисляемые значения и эффекты; здесь же работает планировщик кадров, который старается удержать приложение плавным даже под нагрузкой.  
Ниже — не сухой справочник, а история того, как устроен этот маленький реактивный мир.

---

## Картина целиком

На верхнем уровне есть три слоя:

1. **Реактивный граф**  
   - `Signal` хранит состояние.  
   - `Computed` выводит одно значение из других.  
   - `Effect` реагирует на изменения и общается с внешним миром (DOM, сеть, логирование и т.п.).

2. **Планировщик (scheduler)**  
   - Приоритизирует эффекты (`high`, `normal`, `low`).  
   - Делит работу по фазам кадра: `update → commit → idle`.  
   - Следит за бюджетом времени и динамически подстраивается под нагрузку.

3. **Инфраструктура**  
   - SSR (`ssrSignal`, `__SSR_STATE__`, `getSSRStore`, `getJsonSSRStore`).  
   - Глобальный обработчик ошибок (`onError`).  
   - Утилиты для тонкой настройки (`batch`, `untracked`, `setPriority`).  

---

## Поллифилы: чтобы всё работало и на сервере

Перед тем как говорить о реактивности, ядро аккуратно выравнивает среду:

- **`performance.now`** — если нет, подменяется реализацией через `Date.now`, чтобы измерения времени работали и в SSR.
- **`requestAnimationFrame` / `cancelAnimationFrame`** — эмуляция через `setTimeout` и `clearTimeout`, чтобы планировщик кадров мог жить без браузера.

Для пользователя это почти прозрачно: вы просто можете вызывать `runFrame`/`flushSync`, не думая о том, клиент это или сервер.

---

## Базовые типы

### `Priority`

```ts
type Priority = 'high' | 'normal' | 'low';
````

Определяет, **когда** будет выполняться эффект:

* `high` — максимально быстро, вне бюджетов;
* `normal` — основная рабочая нагрузка;
* `low` — фоновая работа, которая не должна мешать кадрам.

---

### `Phase`

```ts
type Phase = 'update' | 'commit' | 'idle';
```

Состояние планировщика в данный момент:

* `update` — выполняются эффекты и пересчёт;
* `commit` — фаза «фиксации» результата (подходит для сбора метрик);
* `idle` — всё отработало, кадр завершён.

---

### `ErrorWhere`

```ts
export type ErrorWhere = 'effect' | 'computed';
```

Просто метка, откуда пришла ошибка — из эффекта или из вычисляемого значения. Нужна для аккуратной, контекстной обработки ошибок.

---

## Глобальные хуки и телеметрия

### `onError(fn)`

```ts
export function onError(fn: (e: unknown, where: ErrorWhere) => void): void;
```

Глобальный крючок для ошибок.

Когда в `Computed` или `Effect` что-то падает, ядро сначала делегирует это сюда. Можно писать логирование, отправку отчётов, отображение ошибок в дев-панели — всё в одном месте.

---

### `__v6stats__` (глобальное окно)

```ts
(globalThis as any).__v6stats__ = { ... };
```

Не экспортируется напрямую, но намеренно лежит на `globalThis` как «окошко» для отладки:

* текущая `phase`;
* длительность последнего кадра;
* размеры очередей `high/normal/low`;
* сколько раз внутри кадра «добирали» `high`.

Можно читать в дев-панели, чтобы понять, как чувствует себя планировщик.

---

## Класс `Signal<T>`

Роль `Signal` — быть **ячейкой состояния**, из которой вырастает весь реактивный граф.

```ts
export class Signal<T = any> { ... }
```

### Конструктор

```ts
new Signal(value: T, equals?: (a: T, b: T) => boolean);
```

* `value` — стартовое значение.
* `equals` — опциональная функция сравнения, чтобы контролировать, считать ли новое значение «тем же самым».

### Свойства и методы

* **`v: T` (getter)**
  Возвращает текущее значение и, если сейчас кто-то вычисляется (`Effect` / `Computed`), добавляет его в зависимые.

* **`v: T` (setter)**
  Обновляет значение и оповещает всех подписчиков, если значение реально изменилось по `equals`/`Object.is`.

Вся магия в том, что вам не нужно вручную подписываться: достаточно прочитать `signal.v` внутри эффекта — и связь уже установлена.

---

## Класс `Computed<T>`

`Computed` — это **выводимое значение**, которое само следит за тем, от чего оно зависит.

```ts
export class Computed<T = any> { ... }
```

### Конструктор

```ts
new Computed(fn: () => T);
```

* `fn` — функция, которая описывает *как* вычислить значение из сигналов и других `Computed`.

### Свойства и методы

* **`v: T` (getter)**
  Возвращает актуальное значение. Если зависимости успели изменить свои значения, пересчитывается перед выдачей.

* **`recompute()`**
  Принудительно пересчитывает значение сейчас. Обычно вызывается автоматически, но иногда удобно дернуть руками (например, в тестах).

* **`markDirty()`**
  Помечает вычисление «устаревшим» и инициирует пересчёт по расписанию. Пользователь обычно не вызывает это сам — ядро делает это, когда меняются сигналы.

`Computed` ведёт себя как «живой кэш»: читаете `v` — получаете последнее корректное значение, а граф сам решает, когда его пересчитать.

---

## Класс `Effect`

`Effect` — это **мост между реактивным миром и внешним**: здесь вы обновляете DOM, отправляете запросы, логируете значения и т.п.

```ts
export class Effect { ... }
```

### Конструктор

```ts
new Effect(
  fn: () => void | (() => void),
  priority: Priority = 'normal',
  opts?: { lazy?: boolean }
);
```

* `fn` — тело эффекта. Может вернуть функцию очистки.
* `priority` — приоритет выполнения (`high`, `normal`, `low`).
* `opts.lazy` — если `true`, первый запуск будет не сразу, а по расписанию.

### Методы

* **`run()`**
  Запускает эффект, пересчитывает зависимости и сохраняет новую функцию очистки.

* **`markDirty()`**
  Помечает эффект как требующий повторного запуска и передаёт его в планировщик.

* **`dispose()`**
  Полностью выключает эффект: вызывает последнюю очистку, удаляет его из всех очередей и отписывает от сигналов.

В обычной жизни вы почти всегда создаёте эффекты через удобную фабрику `effect(...)`, а не напрямую через `new`.

---

## Фабрики и утилиты для реактивности

### `signal(init, equals?)`

```ts
export const signal = <T>(v: T, equals?: (a: T, b: T) => boolean) => new Signal<T>(v, equals);
```

Простой способ создать сигнал.
Результат — объект `Signal<T>` с геттером/сеттером `.v`.

---

### `signalClient(init)`

```ts
export function signalClient<T>(init: () => T): Signal<T | null>;
```

Сигнал, который **инициализируется только на клиенте**:

* на сервере имеет значение `null`;
* в браузере сразу получает результат `init()`.

Хорошо подходит для того, что невозможно вычислить на сервере: `window.innerWidth`, `localStorage`, доступность API браузера.

---

### `computed(fn)`

```ts
export const computed = <T>(fn: () => T) => new Computed<T>(fn);
```

Синтаксический сахар над `new Computed(fn)`.
Используется для описания «производных» значений.

---

### `effect(fn, priority?, opts?)`

```ts
export const effect = (
  fn: () => void | (() => void),
  priority: Priority = 'normal',
  opts?: { lazy?: boolean }
) => new Effect(fn, priority, opts);
```

Главный способ создавать эффекты.

Пример того, как это обычно выглядит:

```ts
const count = signal(0);
const doubled = computed(() => count.v * 2);

effect(() => {
  console.log('count =', count.v, 'doubled =', doubled.v);
});
```

---

## Планировщик и жизненный цикл кадра

Реактивность без контролируемого планировщика быстро превращается в хаос. Здесь шедулер работает как дирижёр: решает, кто и когда играет свою партию.

### Очереди и приоритеты

Внутри ядра есть три очереди:

* `high` — самые важные эффекты;
* `normal` — типичные обновления;
* `low` — фоновая работа.

Пользователь напрямую с очередями не работает — вместо этого вы выбираете приоритет при создании эффекта или меняете его через `setPriority`.

---

### `flushSync()`

```ts
export function flushSync(): void;
```

Мгновенно выполняет все запланированные эффекты до тех пор, пока очереди пусты.

Подходит для:

* тестов;
* SSR;
* редких случаев, когда нужно «дожать» все реакции прямо сейчас.

---

### `runFrame()`

```ts
export function runFrame(): void;
```

Один кадр работы планировщика:

* выполняет эффекты разными приоритетами;
* учитывает бюджеты времени на `normal` и `low`;
* собирает телеметрию и адаптирует бюджеты под реальные условия.

Обычно вызывается через `requestAnimationFrame`, который планирует ядро само. Но при необходимости можно дергать вручную.

---

### `batch(fn)`

```ts
export function batch(fn: () => void): void;
```

Группирует несколько изменений сигналов так, чтобы эффекты не перезапускались по одному на каждое изменение.

Внутри `batch` вы можете:

* менять множество сигналов;
* быть уверенным, что эффекты запустятся уже по «готовому» состоянию.

---

### `setPriority(eff, priority)`

```ts
export function setPriority(eff: Effect, p: Priority): void;
```

Позволяет динамически **переключать приоритет** уже существующего эффекта.

Например, когда важность UI-обновления меняется в зависимости от того, находится ли пользователь в зоне видимости компонента.

---

## Работа с трекингом зависимостей

### `untracked(fn)`

```ts
export function untracked<T>(fn: () => T): T;
```

Выполняет `fn` так, как будто реактивного контекста нет.

Чтение сигналов внутри `untracked` **не будет** создавать зависимостей. Это удобно:

* для чтения состояния «просто ради логики»;
* для очистки (`cleanup`) в эффектах, чтобы она не влияла на граф.

---


## SSR: мост между сервером и клиентом

Задача SSR-слоя простая:  
одно и то же состояние должно быть доступно **и на сервере, и на клиенте**, под одним и тем же id.

Для этого есть:

- общий объект `__SSR_STATE__`;
- сигналы с явным идентификатором — `SSRSignal`.

---

### `__SSR_STATE__`

```ts
export const __SSR_STATE__: Record<string, any> = {};
````

Это просто словарь на **сервере**:

* ключ — строковый `id`, который ты сам придумал;
* значение — текущее значение сигнала.

Потом этот словарь как-то попадает в браузер
(например, через `getSSRStore()` в инлайновом скрипте)
и становится `window.__SSR_STATE__`.

---

### `SSRSignal<T>`

```ts
export type SSRSignal<T> = Signal<T> & { __ssrId: string };
```

Обычный `Signal<T>`, но с полем `__ssrId`.
По этому id сигнал находит своё значение в `__SSR_STATE__` и продолжает жить уже на клиенте.

---

### `ssrSignal(initial, explicitId)`

```ts
export function ssrSignal<T>(initial: T, explicitId: string): SSRSignal<T> { ... }
```

Здесь ты сам говоришь:

> «Вот это состояние всегда будет жить под id `explicitId`. И на сервере, и в браузере.»

#### Параметры

* `initial` — начальное значение, если ничего не прилетело из SSR.
* `explicitId` — строковый id, который ты гарантируешь сохранить одинаковым.

#### На клиенте

Если код выполняется в браузере:

1. Создаётся сигнал с `initial`.
2. Читается `window.__SSR_STATE__`.
3. Если там есть `explicitId`, значение подтягивается из стора и ключ оттуда удаляется.

Если ключа нет — используется `initial`.

#### На сервере

Если код выполняется на сервере:

* Сигнал создаётся с `initial`.
* Значение записывается в `__SSR_STATE__[explicitId]`.
* При дальнейших изменениях сигнала в это же поле попадает новое значение.

Сервер всегда знает последнюю версию этого сигнала и может отдать её клиенту.

---

### Как думать про `explicitId`

С явным id всё просто:

* id — это часть контракта API;
* его можно сделать «говорящим»: `"ui.theme"`, `"cart.items"`, `"auth.token"`;
* по нему легко искать и понимать, кто к чему привязан.

Главное правило: если на сервере и на клиенте ты используешь **один и тот же** `explicitId`,
состояние правильно «склеится» при гидратации.

---
## Итог

`core` — это не просто набор классов и функций, а маленькая экосистема:

* **сигналы** описывают, *что* за состояние у вас есть;
* **computed** объясняют, *как одно вытекает из другого*;
* **эффекты** рассказывают миру об изменениях;
* **планировщик** следит за тем, чтобы всё это происходило плавно и вовремя;
* **SSR-слой** поддерживает иллюзию непрерывности между сервером и клиентом.

Используя этот модуль, вы не столько «дергаете методы», сколько работаете с живым графом, который сам следит за тем, чтобы ваши данные и UI оставались синхронизированными.

---
