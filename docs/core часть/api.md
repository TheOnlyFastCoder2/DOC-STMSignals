# Reactive Core API

## Введение

Reactive Core — это маленький, злой (в хорошем смысле) движок реактивности: ты кладёшь туда состояние, а он сам понимает, **что от чего зависит**, и **когда** это надо пересчитать или запустить.

Это не UI-фреймворк и не полноценный state-management комбайн. Тут нет компонентов, роутинга и магии вокруг рендера. Это маленькое реактивное ядро: signals/computed/effects + планировщик, который управляет порядком и моментом выполнения эффектов (с приоритетами и кадрами), чтобы обновления не превращались в лаги.

---

## Signal — состояние, которое само строит зависимости

Представь, что у тебя есть значение. Обычное. Скучное. Например счётчик. И ты хочешь, чтобы всё вокруг на него реагировало — но без ручных подписок, без “не забудь вызвать update()”, без “почему я забыл invalidate кэш”. Вот здесь на сцену выходит **Signal**.

Signal — это не просто переменная. Это переменная, которая **помнит, кто на неё смотрел**, и умеет аккуратно шепнуть этим наблюдателям: “эй, я изменилась”.

```ts
import { signal, effect } from './index';

const count = signal(0);

effect(() => {
  console.log('count =', count.v);
});

count.v = 1; // эффект сработает
count.v = 1; // не сработает (значение то же)
```

Секрет здесь в `.v`: чтение `count.v` внутри `effect` или `computed` автоматически строит зависимость. А запись в `count.v` запускает цепочку обновлений — но только если значение реально изменилось (`Object.is` или твой `equals`).

Иногда `Object.is` — слишком честный. Например, у тебя объект, и ты хочешь, чтобы сигнал **не будил граф**, если “по смыслу” ничего не поменялось. Для этого у `signal(value, equals)` есть второй аргумент: функция сравнения.

Пример: считаем объекты “равными”, если не изменилось поле `id`:

```ts
import { signal, effect } from './index';

type User = { id: string; name: string };

const user = signal<User>(
  { id: '1', name: 'Alice' },
  (a, b) => a.id === b.id
);

effect(() => {
  console.log('user:', user.v.name);
});

user.v = { id: '1', name: 'Alicia' }; // effect НЕ сработает (id тот же)
user.v = { id: '2', name: 'Bob' };    // effect сработает (id другой)
```

Смысл простой: `equals` — это твой способ сказать движку “не буди подписчиков, если для моего мира это то же самое”.

---

### Signal.u — “вторая дверь”: читать и писать тихо

И вот тут начинается первая “вау-фишка”, о которой любят забывать в доках, а потом страдать в проде: у Signal есть **вторая дверь** — `.u`.

`.u` — это режим “я просто посмотрю” и “я тихонько поправлю”.

* `signal.u` читает **без подписки**
* `signal.u = ...` записывает **без уведомления подписчиков**

Это как сервисный вход в здание: через парадный (`.v`) заходят все и включается свет, а через чёрный (`.u`) можно занести коробку ночью и никого не будить.

```ts
import { signal, effect } from './index';

const s = signal(0);

effect(() => console.log('watch', s.v));

s.u = 123;  // тихо: эффект НЕ проснётся
console.log(s.u); // тоже без подписки
```

Зачем это вообще нужно? Например, когда ты делаешь инициализацию, гидрацию, или техническую синхронизацию состояния, и ты **сам** контролируешь, когда запускать реактивность. `.u` — это мощно, но с характером: если ты ожидаешь, что UI обновится, а использовал `.u` — UI не виноват, это ты вошёл через сервисный вход.

---

### signalClient — когда значение существует только в браузере

Иногда состояние невозможно честно создать на сервере, потому что оно живёт в `window` (ширина экрана, `matchMedia`, `navigator`, да хоть “есть ли фокус у вкладки”). Для таких случаев есть `signalClient(() => ...)`: на сервере это будет `null`, а на клиенте сигнал сразу возьмёт значение из `init()`.

```ts
import { signalClient, effect } from './index';

const width = signalClient(() => window.innerWidth);

effect(() => {
  console.log('width =', width.v); // SSR: null, Client: число
});
```

---

## Computed — производные значения с кешем (и честными ошибками)

Дальше в истории появляется **Computed**. Computed — это твой личный алхимик: он берёт сигналы, смешивает, и выдаёт новое значение… но делает это умно. Он **кеширует результат** и пересчитывает только когда нужно.

```ts
import { signal, computed } from './index';

const count = signal(2);
const doubled = computed(() => count.v * 2);

console.log(doubled.v); // 4
count.v = 5;
console.log(doubled.v); // 10
```

Но самое интересное в Computed — его честность. Если вычисление упало, он не делает вид, что “ничего не было”. Он **запоминает ошибку** и будет бросать её при чтении `.v`, пока не сможет успешно пересчитаться. Это очень “производственно”: ты не получаешь случайных полу-значений, ты получаешь стабильную правду — пусть и неприятную.

---

### safeSnapshot — “капсула безопасности” для UI

И именно поэтому рядом с computed живёт спасательная капсула для UI: **safeSnapshot**. Она читает `Signal` или `Computed`, но если там ошибка — не валит мир, а возвращает аккуратный объект с ошибкой.

```ts
import { computed, safeSnapshot } from './index';

const risky = computed(() => {
  throw new Error('boom');
});

const snap = safeSnapshot(risky);
if ('__stmError' in snap) {
  console.log('UI жив, показываем fallback');
} else {
  console.log('value =', snap);
}
```

---

## Effect — реакция + побочки + cleanup

Теперь про **Effect** — это тот, кто делает что-то “наружу”: лог, DOM, запрос, подписку на событие. Он запускается, когда меняется то, что он читает, но есть важный нюанс: **эффект не обязан срабатывать на каждую промежуточную запись**. Если ты меняешь один и тот же сигнал несколько раз подряд в одном тике, эффект обычно увидит **последнее значение** (потому что подписчики помечаются dirty и планируются один раз).

То есть вот так — сработает один раз на `2`:

```ts
const count = signal(0);

effect(() => {
  console.log('count =', count.v);
});

count.v = 1;
count.v = 2; // эффект сработает один раз и увидит 2
```

А повторная запись того же значения **не будит эффект**, даже если сделать её в другом тике:

```ts
count.v = 1; // effect сработает
setTimeout(() => {
  count.v = 1; // effect всё равно не сработает: значение "кэшируется"
}, 0);
```

И у эффекта есть важная привычка взрослого человека: он умеет **cleanup**. То есть эффект может вернуть функцию, которая будет вызвана перед следующим запуском эффекта и при `dispose()`.

```ts
import { signal, effect } from './index';

const on = signal(true);

const stop = effect(() => {
  if (!on.v) return;

  const id = setInterval(() => console.log('tick'), 500);
  return () => clearInterval(id);
});

on.v = false;   // cleanup выполнится
stop.dispose(); // cleanup тоже выполнится и всё отцепится
```

---

### Lazy-эффекты — когда не хочется “срабатывать прямо сейчас”

Обычно effect запускается сразу после создания — чтобы прочитать сигналы и построить зависимости. Но если тебе нужно сначала подготовить окружение, используй `{ lazy: true }`: эффект не выполнится мгновенно, а начнёт жить только когда что-то реально изменится.

```ts
import { signal, effect } from './index';

const s = signal(0);

effect(() => {
  console.log('lazy effect:', s.v);
}, 'normal', { lazy: true });

s.v = 1; // теперь эффект впервые выполнится
```

---

### Планировщик — приоритеты, кадры и sync

Но Reactive Core — не просто “реактивность”. У него есть режиссёр: **планировщик**. И вот он делает библиотеку по-настоящему вкусной.

Эффекты бывают четырёх “характеров” (kind): `'high' | 'normal' | 'low' | 'sync'`.

* `high/normal/low` живут в режиме **frame**: они собираются в очереди и выполняются в кадре через `requestAnimationFrame`.
* `sync` — это эффект, который выполняется **сразу**, как только стал dirty. Без кадра, без ожидания.

```ts
import { signal, effect } from './index';

const s = signal(0);

effect(() => console.log('HIGH', s.v), 'high');
effect(() => console.log('LOW', s.v), 'low');
effect(() => console.log('SYNC', s.v), 'sync');

s.v = 1; // SYNC сразу, HIGH/LOW — по кадру (если глобально frame)
```

И тут начинается инженерная магия: `high` в кадре идёт без бюджетов, `normal/low` — с бюджетами, и ядро старается не устроить “голодание” low-очереди. Плюс, когда вкладка скрыта, RAF не крутится — CPU не горит, батарейка не плачет. А если хочешь понять, что вообще творится — есть телеметрия в `globalThis.__v6stats__`:

```ts
console.log((globalThis as any).__v6stats__);
/*
{
  phase: 'update' | 'commit' | 'idle',
  lastFrameDuration: number,
  lastFrameTotal: number,
  highBursts: number,
  queues: { high: number, normal: number, low: number }
}
*/
```

---

## Утилиты контроля — batch и untracked

Теперь про контроль. Иногда ты хочешь сделать много изменений, но чтобы эффект отработал один раз, в конце, на финальном состоянии. Для этого есть **batch**: внутри него эффекты не запускаются сразу, они копятся.

```ts
import { signal, effect, batch } from './index';

const a = signal(1);
const b = signal(2);

effect(() => console.log('sum =', a.v + b.v));

batch(() => {
  a.v = 10;
  b.v = 20;
}); // один запуск: sum = 30
```

Если ты хочешь “прочитать, но не подписаться” — есть **untracked**. Это как сказать реактивному движку: “я сейчас просто посмотрю, не записывай это в зависимость”.

```ts
import { signal, effect, untracked } from './index';

const a = signal(0);
const b = signal(100);

effect(() => {
  console.log('a:', a.v);
  console.log('b snapshot:', untracked(() => b.v)); // b не триггерит effect
});
```

---

## Утилиты планировщика — setSchedulerMode, setPriority и flushSync

Иногда ты хочешь поменять поведение всего движка: кадры или синхрон. Для этого есть `setSchedulerMode('frame' | 'sync')` — это переключатель “режима жизни” планировщика. В режиме `frame` эффекты (кроме `kind: 'sync'`) не выполняются сразу: они складываются в очереди и запускаются в ближайшем кадре через `requestAnimationFrame`. Это даёт плавность и контроль по приоритетам. В режиме `sync` планировщик вообще не ждёт кадра: как только сигнал меняется и помечает эффекты dirty, они выполняются немедленно (в текущем тике). Поэтому `sync` очень удобен в тестах и в ситуациях, когда нужна железная детерминированность.

```ts
import { setSchedulerMode, signal, effect } from './index';

setSchedulerMode('sync');

const s = signal(0);
let seen = 0;

effect(() => { seen = s.v; });

s.v = 42;
console.log(seen); // 42 сразу, без RAF
```

Иногда меняется не режим, а важность задачи: то, что вчера было “фоном”, сегодня внезапно становится критичным. Для таких моментов есть `setPriority(effect, 'high' | 'normal' | 'low')` — переключатель приоритета уже существующего frame-эффекта.

```ts
import { signal, effect, setPriority } from './index';

const s = signal(0);

const e = effect(() => {
  console.log('work:', s.v);
}, 'low');

// позже стало важно
setPriority(e, 'high');
```

`flushSync()` — это не “ещё один режим”, а скорее кнопка “сейчас же закончить начатое”. Она нужна именно в `frame`-режиме, когда эффекты уже накопились в очередях (high/normal/low), но тебе по какой-то причине нужно получить результат **немедленно**, не дожидаясь кадра. `flushSync()` отменяет ожидающий RAF (если он уже запланирован) и вычищает очереди прямо сейчас, прогоняя их до пустоты.

То есть разница такая:
— `setSchedulerMode('sync')` меняет поведение **на будущее**: теперь всё будет выполняться сразу.
— `flushSync()` — это разовая команда: “выполни прямо сейчас то, что уже накопилось (и что накопится во время выполнения)”.

```ts
import { signal, effect, flushSync } from './index';

const s = signal(0);
effect(() => console.log('frame', s.v), 'low');

s.v = 1;     // в frame-режиме эффект попадёт в очередь кадра
flushSync(); // но мы принудительно выполняем очередь немедленно
```

---

## onError — глобальный громоотвод ошибок

Ещё одна важная штука — **onError**. Это твой глобальный громоотвод. Реактивность — штука хитрая: ошибка может вылететь из computed или effect, и ты хочешь поймать её централизованно, красиво залогировать, возможно, отправить в мониторинг.

```ts
import { onError, effect, computed } from './index';

onError((e, where) => {
  console.error('Reactive error in', where, e);
});

const bad = computed(() => {
  throw new Error('nope');
});

effect(() => {
  // чтение bad.v приведёт к ошибке, которая уйдёт в onError
  console.log(bad.v);
});
```

---

## SSR поддержка

И наконец SSR. Тут библиотека ведёт себя как хороший роман: она не обрывает сюжет на сервере. `ssrSignal(initial, id)` на сервере складывает своё значение в `__SSR_STATE__`, а на клиенте забирает его из `window.__SSR_STATE__` и сразу удаляет ключ, чтобы стор не разрастался. `getSSRStore()` — это “готовый скрипт с данными”: ты вставляешь его в `<script>` на SSR-странице, браузер выполняет его первым делом, и поэтому клиент сразу видит данные в `window.__SSR_STATE__`.

```ts
import { ssrSignal, getSSRStore } from './index';

export const user = ssrSignal<{ name: string } | null>(null, 'user');

// server
user.v = { name: 'Alice' };

// html (SSR)
const script = getSSRStore(); // вставь в <script>...</script>
```

Если нужен не готовый скрипт, а просто JSON — есть `getJsonSSRStore()`.

---
