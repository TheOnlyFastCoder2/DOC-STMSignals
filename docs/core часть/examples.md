## Примеры и паттерны использования

Теория — это хорошо, но хочется увидеть, **как этим реально пользоваться в приложении**.  
Ниже — набор небольших историй: от простых сигналов до SSR и приоритетов эффектов.

Во всех примерах будем считать, что мы импортируем всё из `core`:

```ts
import {
  signal,
  signalClient,
  computed,
  effect,
  batch,
  untracked,
  ssrSignal,
  setPriority,
  flushSync,
} from './core';
````

---

### 1. Самый базовый кейс: `signal` + `effect`

Представим простой счётчик:

```ts
const count = signal(0);

effect(() => {
  console.log('Текущее значение:', count.v);
});

count.v = 1;
count.v = 2;
```

Что здесь происходит:

* `signal(0)` создаёт реактивное число.
* `effect` один раз запускается, читает `count.v` и автоматически подписывается.
* При каждом изменении `count.v` эффект запускается снова и печатает новое значение.

Это базовый паттерн: **сигнал хранит состояние, эффект реагирует**.

---

### 2. Слой смысла: `computed` как «выводимое» состояние

Допустим, нам нужно не только `count`, но и `count * 2`:

```ts
const count = signal(1);
const doubled = computed(() => count.v * 2);

effect(() => {
  console.log('count =', count.v, 'doubled =', doubled.v);
});

count.v = 2;
// лог автоматически показывает обновлённые оба значения
```

Здесь:

* `computed` описывает «как получить» значение, а не «когда пересчитать».
* Пересчёт происходит только тогда, когда реально меняется `count`.
* Эффект видит уже готовые, согласованные значения.

Так удобно строить цепочки логики:
**сигналы — про «факты», computed — про «выводы из фактов»**.

---

### 3. Формы и локальное состояние

Простой пример с формой:

```ts
const firstName = signal('');
const lastName = signal('');

const fullName = computed(() => `${firstName.v} ${lastName.v}`.trim());

effect(() => {
  document.title = fullName.v || 'Без имени';
});
```

* Поля формы — обычные сигналы.
* `fullName` — вычисляемое поле, не нужно хранить его отдельно.
* Любое изменение имени автоматически подхватывается в `document.title`.

---

### 4. `signalClient`: только-клиентское состояние

Иногда значение **невозможно** получить на сервере
(например, ширина окна или данные из `localStorage`).

```ts
const viewportWidth = signalClient(() => window.innerWidth);

effect(() => {
  console.log('Текущая ширина окна:', viewportWidth.v);
});

window.addEventListener('resize', () => {
  viewportWidth.v = window.innerWidth;
});
```

* На сервере `viewportWidth.v` будет `null`.
* На клиенте — инициализируется через колбэк, как только код дойдёт до этой строки.

---

### 5. `untracked`: временно выйти из реактивности

`untracked(fn)` — это способ сказать ядру:

> «Сейчас я хочу сделать что-то с сигналами,  
> но **не хочу**, чтобы текущий `effect` / `computed` зависел от этих чтений/записей».

Он работает только когда уже есть текущий контекст (`effect` или `computed`).

---

#### Пример: читать и менять состояние, не создавая зависимость

```ts
const a = signal(0);
const b = signal(0);

effect(() => {
  // Эффект ЗАВИСИТ от a
  console.log('a =', a.v);

  // А вот здесь мы выходим из контекста эффекта
  untracked(() => {
    // Можно и читать, и писать сигналы,
    // но эффект от этого НЕ станет зависеть от b
    b.v = a.v * 2;
    console.log('debug b =', b.v);
  });
});
```

Что важно:

* изменение `a.v` перезапускает эффект (как обычно);
* изменение `b.v` **НЕ** перезапускает этот эффект,
  потому что все операции с `b` были внутри `untracked` и не попали в граф зависимостей.

---

#### Когда это полезно

* избежать лишних зависимостей внутри сложного `effect` / `computed`;
* сделать «служебные» обновления (лог, кеш, зеркальный сигнал),
  которые не должны превращаться в триггеры для текущего эффекта;
* разорвать потенциальный фидбек-петлю вроде «эффект пишет в сигнал, на который сам же и подписан».

Снаружи эффектов/компьютедов `untracked` практически бессмысленен —
там и так нет активного контекста, за который нужно «выходить».

### 6. `batch`: много изменений как одна «транзакция»

`batch` нужен, чтобы отнестись к серии изменений как к **одной операции**.

Даже без `batch` несколько простых записей подряд обычно попадают в один тик планировщика, и эффекты в итоге срабатывают один раз за кадр. Но `batch` делает границу явной: внутри него можно спокойно менять состояние, не думая о промежуточных состояниях.

```ts
const a = signal(1);
const b = signal(2);

const sum = computed(() => a.v + b.v);

effect(() => {
  console.log('sum =', sum.v);
});

// где-то в обработчике клика или экшене
batch(() => {
  a.v = 10;
  b.v = 20;
  // здесь же можно обновить ещё несколько сигналов
});

// эффект увидит уже готовое конечное состояние
// и отработает по результату всех изменений сразу


```
Идея простая: **внутри `batch` вы свободно меняете несколько сигналов**,
а уже после блока ядро аккуратно пересчитывает граф и запускает нужные эффекты.

Особенно полезно, когда:

* обновляете много полей формы за один экшен;
* меняете сложную структуру по частям;
* синхронизируете несколько связанных сигналов и не хотите мелькания «промежуточных» значений.



### 7. Приоритеты эффектов: `Priority` и `setPriority`

Не все эффекты одинаково важны.
Например, анимация скролла важнее логирования или синхронизации с сервером.

```ts
const x = signal(0);

// Важный визуальный эффект
const paintEffect = effect(
  () => {
    renderSpriteAt(x.v);
  },
  'high' // высокий приоритет
);

// Фоновая аналитика
const analyticsEffect = effect(
  () => {
    sendAnalytics({ x: x.v });
  },
  'low' // низкий приоритет
);
```

Позже приоритет можно изменить:

```ts
setPriority(analyticsEffect, 'normal');
```

Планировщик постарается:

* `high` выполнить в первую очередь и без жёстких ограничений;
* `normal` вписать в основной бюджет кадра;
* `low` делать только если осталось время, либо иногда «по форсу», чтобы не голодали.

---

### 8. SSR: один и тот же сигнал на сервере и клиенте

Пример с темой интерфейса:

```ts
// на сервере/в общем коде
const theme = ssrSignal<'light' | 'dark'>('light', 'ui.theme');

effect(() => {
  document.documentElement.dataset.theme = theme.v;
});
```

* На сервере текущее значение окажется в `__SSR_STATE__['ui.theme']`.
* Это значение отправляется на клиент (через `getSSRStore` или свой механизм).
* На клиенте `ssrSignal` найдёт запись по id `ui.theme` и восстановит её в сигнал.

Дальше всё работает так же, как с обычным `signal`,
но с бонусом: **при первом рендере на клиенте тема уже совпадает с серверной**.

---

### 9. Тесты и синхронный прогон: `flushSync`

Иногда хочется в тесте сказать:
«Сделай всё реактивное прямо сейчас, и я проверю результат».

```ts
const count = signal(0);
const doubled = computed(() => count.v * 2);

let last;
effect(() => {
  last = doubled.v;
});

count.v = 10;

// где-нибудь в тесте:
flushSync();
console.assert(last === 20);
```

* `flushSync` вычищает все очереди эффектов синхронно.
* После него можно уверенно проверять состояние и побочные эффекты.

---

### 10. Композиция: живой кусочек UI

Маленький законченный кусок — счётчик с SSR и приоритетами:

```ts
// состояние, которое переживает SSR под id "counter.value"
const counter = ssrSignal(0, 'counter.value');

// производное значение
const label = computed(() =>
  counter.v === 0 ? 'Нажми меня' : `Счётчик: ${counter.v}`
);

// быстрый эффект для UI
const uiEffect = effect(
  () => {
    const btn = document.getElementById('counter-btn');
    if (btn) btn.textContent = label.v;
  },
  'high'
);

// менее важный эффект — логирование
const logEffect = effect(
  () => {
    console.log('Счётчик изменился:', counter.v);
  },
  'low'
);

function onClick() {
  batch(() => {
    counter.v++;
    // здесь можно обновить ещё что-нибудь, и всё сработает одним проходом
  });
}
```

Здесь в одном месте видно почти всё:

* `ssrSignal` даёт устойчивое состояние между сервером и клиентом;
* `computed` добавляет слой смысла;
* два `effect` с разными приоритетами реагируют на изменения;
* `batch` сгруппировал изменения так, чтобы реактивный граф отреагировал красиво и аккуратно.

---

Этот раздел можно читать как «поваренную книгу» по core:
взять нужный паттерн, адаптировать под свой кейс и собирать из них более сложные сценарии.
