---
sidebar_position: 2
---

# SSR + сигналы: одна история на сервере и продолжение на клиенте

Есть два типа приложений.

В первом ты заходишь на страницу — и чувствуешь, как оно живёт: список уже на месте, всё быстро, никаких “загрузка…”, никаких лишних запросов, никаких странных миграций состояния.

Во втором ты заходишь — и начинается сериал: сначала запрос, потом ещё один, потом “ой, мы потеряли кэш”, потом “а почему это грузится дважды”, потом “а где хранить данные, чтобы и SSR, и клиент были довольны”.

SSR в Reactive Core — это способ всегда быть в первом типе. Не потому что “мы так решили”, а потому что тут есть очень простая, почти литературная сцена:

**сервер добывает данные → кладёт их в `ssrSignal` → рендерит HTML → в `<script>` зашивает состояние → браузер читает его первым делом → клиент продолжает с того же места, где закончился сервер.**

Без обрывов сюжета.

---

## `ssrSignal` — сигнал, который умеет “переезжать”

Обычный `signal` живёт там, где ты его создал. `ssrSignal` живёт в двух мирах одновременно:

* на сервере он ведёт себя как нормальный сигнал, только **плюс** записывает своё значение в SSR-стор;
* на клиенте он первым делом заглядывает в `window.__SSR_STATE__`, забирает своё значение **и удаляет ключ**, чтобы стор не превращался в мусорный склад.

Тебе нужно всего одно: **стабильный id**. Это как название главы в книге: по нему клиент понимает, что именно продолжать.

```ts
// api/projects/store.ts
import { ssrSignal } from '../index';

export interface Project {
  id: string;
  title: string;
  // ...
}

export const sgProjects = ssrSignal<Project[]>([], '/projects');
```

`'/projects'` — это тот самый “якорь сюжета”. Где бы ты ни читал `sgProjects.v`, источник один.

---

## Наполняем сигнал на сервере: “один запрос — одна правда”

Теперь важный момент, который обычно ломает людям SSR: **кто-то должен успеть наполнить данные до того, как сервер начнёт рендерить HTML.** И этим кем-то должен быть loader.

Сделаем API-слой, который не просто возвращает результат, а кладёт его в сигнал. Потому что сигнал — это не “сервисная переменная”. Это реальный единый источник правды, к которому потом будут обращаться и список, и детали, и любые другие страницы.

```ts
// api/projects/index.ts
import { sgProjects, type Project } from './store';

// псевдо-API — подставь свой directus/fetch/whatever
async function fetchProjects(): Promise<Project[]> {
  const res = await fetch('https://example.com/api/projects');
  return res.json();
}

async function fetchProject(id: string): Promise<Project> {
  const res = await fetch(`https://example.com/api/projects/${id}`);
  return res.json();
}

export const project = {
  list: async () => {
    const result = await fetchProjects();
    sgProjects.v = result;              // ← кладём в сигнал
    return result;
  },

  get: async (id: string) => {
    const cached = sgProjects.v.find((p) => p.id === id);
    if (cached) return cached;          // ← сперва кэш (сигнал)

    const one = await fetchProject(id); // ← если нет — догружаем
    sgProjects.v = [...sgProjects.v, one];
    return one;
  },
};
```

Обрати внимание на тонкость: `get()` не “делает запрос по умолчанию”. Он сначала смотрит в сигнал. Это маленькая дисциплина, которая потом экономит десятки запросов.

---

## Loader: сервер наполняет сигнал до рендера

Теперь тот самый момент, где сюжет разворачивается правильно. На SSR ты делаешь вызов, который гарантированно наполнит сигнал. После этого сервер может рендерить компоненты — и они уже увидят данные, будто они всегда там были.

```ts
// root.tsx / server loader
import { project } from 'api/projects';

export async function loader() {
  await project.list(); // ← на SSR заполняем sgProjects
  return null;
}
```

Вот и всё. Не нужно ничего возвращать, не нужно протаскивать в пропсы, не нужно собирать мега-объект “hydration data”. Данные уже в сигнале.

---

## `getSSRStore()` — “готовый скрипт с данными”, который вставляется в HTML

Теперь серверу нужно сделать одну вещь: объяснить клиенту, с какими данными он должен стартовать.

`getSSRStore()` — это не “объект”. Это уже **готовый кусок JavaScript**, который делает одну простую вещь: записывает все `ssrSignal` в `window.__SSR_STATE__`.

Ты вставляешь его в `<script>` на SSR-странице (обычно в `<head>`), браузер выполняет его до гидрации — и тогда `ssrSignal` на клиенте сразу подхватывает своё значение.

Пример (Router/Remix style layout):

```tsx
// root.tsx
import { getSSRStore } from '../index';

export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        {/* meta, links, styles... */}

        <script
          dangerouslySetInnerHTML={{
            __html: getSSRStore(),
          }}
        />
      </head>
      <body>
        {children}
        {/* scripts */}
      </body>
    </html>
  );
}
```

Как это ощущается на практике:

* сервер заполнил `sgProjects.v`;
* сервер отрендерил HTML;
* `getSSRStore()` добавил “письмо в будущее” в виде `<script>`;
* браузер открыл письмо — и положил данные в `window.__SSR_STATE__`;
* клиентские `ssrSignal` прочитали их и продолжили как ни в чём не бывало.

Если тебе нужно не “готовый скрипт”, а просто JSON (например, ты хочешь сам решать, куда класть данные), есть `getJsonSSRStore()`.

---

## Компоненты: читать можно просто `.v`, а можно реактивно

Вот приятное отличие от большинства схем: ты не обязан использовать специальный хук, чтобы “получить SSR-данные”. Если сигнал уже наполнен, ты можешь читать `.v` напрямую.

Это особенно кайфово, когда компонент рендерится на сервере: там нет “подписки”, там просто чтение данных и рендер HTML.

```tsx
import { sgProjects } from 'api/projects/store';

export function ProjectsList() {
  const projects = sgProjects.v;

  return (
    <ul>
      {projects.map((p) => (
        <li key={p.id}>{p.title}</li>
      ))}
    </ul>
  );
}
```

Но если ты хочешь, чтобы **на клиенте** React перерендеривался при изменениях сигнала (например, ты добавляешь проекты после загрузки) — тогда ты подключаешь мостик `useSignalValue`.

```tsx
import { sgProjects } from 'api/projects/store';
import { useSignalValue, isErrorSnapshot, renderValue } from 'shared/utils/_stm/react/react';

export function ProjectsList() {
  const projects = useSignalValue(sgProjects);

  return (
    <ul>
      {projects.map((p) => (
        <li key={p.id}>{p.title}</li>
      ))}
    </ul>
  );
}
```

В этом месте сюжет становится очень спокойным: SSR дал старт, React подписался “правильным способом”, и дальше всё просто работает.

---

## Детальная страница: один кэш на весь проект, без повторных запросов

Самая вкусная сцена — когда у тебя есть список и **страница проекта**.

Ты кликаешь из списка в страницу проекта. В большинстве архитектур эта страница снова делает запрос, потому что “так проще”. Здесь проще иначе: страница проекта вызывает `project.get(id)`, а `get()` первым делом ищет проект в `sgProjects`. И если он там — запроса не будет: данные уже лежат в общем сигнале.

```ts
// route loader
import { project } from 'api/projects';

export async function loader({ params }: { params: { id: string } }) {
  const data = await project.get(params.id); // сначала смотрит в sgProjects
  if (!data) throw new Response('Not found', { status: 404 });
  return data;
}
```

И получается ровно то, что хочется:

* если ты пришёл на страницу проекта **со страницы списка**, список уже наполнил сигнал → `get()` просто нашёл проект в памяти;
* если ты открыл страницу проекта напрямую, `get()` сделает ровно один запрос и добавит результат в общий сигнал;
* после этого и список, и страница проекта смотрят в одно и то же место — `sgProjects`.

---

## Финальная картинка (и почему это ощущается “как надо”)

Ты не строишь “SSR-архитектуру”. Ты просто используешь сигналы по-человечески:

* **данные живут в `ssrSignal`** и доступны где угодно;
* **loader наполняет сигнал на сервере** до рендера;
* **`getSSRStore()` вставляется в `<head>`** и делает мостик на клиент;
* **клиент продолжает**, не делая повторных запросов;
* **вся логика кэша** — это честное чтение/запись одного сигнала.
