# Active — контроль жизни DOM

## Введение

Active — это маленький реактивный “привратник” для React: он решает, **когда вообще показывать кусок дерева** и **когда его пересчитать**, но делает это не через цепочку `useState/useMemo/memo`, а через твои сигналы и `useWatch`.

И это особенно приятно в модалках. Потому что “реальная боль” в React обычно выглядит так: Popup/Modal перерендерился из-за какой-нибудь мелочи → DOM пересоздался → enter-анимация снова стартанула (или наоборот сбросилась), и ты начинаешь плясать с мемоизацией. Active позволяет сделать проще: ты даёшь конкретному месту один сигнал-триггер “показываться/не показываться”, и оно живёт своей жизнью, не дёргая весь Popup.

---

## Что делает Active

Представь, что у тебя есть кусок UI, который должен появляться только “в правильный момент”. Не «когда React решит», не «когда родитель перерендерится», а по твоему правилу. Active — это именно такой шлагбаум: он читает сигналы, понимает, “да/нет”, и либо **пускает DOM внутрь**, либо **держит дверь закрытой**. В итоге у тебя появляется ощущение контроля: ты не лечишь последствия перерендеров, ты заранее ставишь привратника там, где они вредят.

---

## API (коротко)

```tsx
<Active
  sg={someSignalOrComputed}
  is={value | values[] | (v => boolean)}
  triggers={[sg1, sg2]}
  callback={(active) => {}}
  ch={() => <YourUI />}
/>
```

---

## Самый частый кейс: сцены внутри модалки, которые не мешают друг другу жить

В модалках часто есть “сцены”: сегодня показываем одну, завтра другую. И хочется, чтобы невидимая сцена **реально исчезала** — без фоновых эффектов, без лишнего DOM, без случайных ресетов анимации.

`type` хранит “какая сцена сейчас”. Каждый `Active` просто смотрит на `type.v` и решает: *мне жить или мне уйти*.

```tsx
const type = useSignal<'Modal1' | 'Modal2'>('Modal1');

<Popup /* ... */>
  <DraggableTest>
    <Active sg={type} is={'Modal1'} ch={() => <Modal1 />} />
    <Active sg={type} is={'Modal2'} ch={() => <Modal2 />} />
  </DraggableTest>
</Popup>
```

Смысл простой: ты не “условно рендеришь где-то сверху”, ты **точечно отдаёшь конкретному месту** правило жизни. И оно не зависит от того, что там дернулось рядом.

---

## Пример по делу: “галочка живёт отдельно” (и не заставляет тебя писать условия руками)

Чекбокс — мелочь, но показательная: вокруг могут жить атрибуты, ошибки, стили, а вот сама иконка галочки должна появляться только когда `isCheck` true. Обычно это превращается в `isCheck.v ? <Svg/> : null` и расползается по коду. С Active это выглядит как декларация: “вот тут показывай, когда true”.

```tsx
interface Props {
  onChange?: (v: boolean) => void;
  initValue?: boolean;
  isError?: Signal<boolean>;
}

export default function Checker({ initValue = false, isError, onChange }: Props) {
  const isCheck = useSignal(initValue);
  const refDiv = useRef<HTMLDivElement>(null);

  useWatch(() => {
    refDiv.current?.toggleAttribute?.('active', isCheck.v);
    refDiv.current?.toggleAttribute?.('error', !!isError?.v);
  }, [isError]);

  const onClick = () => {
    isCheck.v = !isCheck.v;
    onChange?.(isCheck.v);
  };

  return (
    <div className={$.Checker} onClick={onClick} ref={refDiv}>
      <Active sg={isCheck} is={true}>
        <Svg className={$.icon} />
      </Active>
    </div>
  );
}
```

---

## triggers: когда условие зависит не только от `sg`

Иногда “пора показывать” зависит от одного сигнала, но **пересчитываться** нужно ещё и по другим событиям. Тут `triggers` как колокольчик: Active просто читает их `.v`, и этого достаточно, чтобы они стали зависимостями.

```tsx
<Active
  sg={type}
  is={'Modal1'}
  triggers={[viewportMove]} // любой сигнал/компьютед
  ch={() => <Modal1 />}
/>
```

---

## Пример из жизни форм: ошибка “согласия” появляется только после submit или после “touched”

Это один из самых полезных паттернов: пользователь ещё не трогал поле — не бесим его ошибками. Но как только он попытался отправить форму или уже “потрогал” чекбокс — показываем сообщение.

Тут `sg` — значение чекбокса, а `triggers` — “сабмитнули форму” и “поле тронули”.

```tsx
<Active
  sg={field.sg.value}
  triggers={[form.isSubmitted, consentTouched]}
  is={() => {
    const checked = !!field.sg.value.v;
    return !checked && (form.isSubmitted.v || consentTouched.v);
  }}
  ch={() => <p className={$.error}>{t('contact.agreementError')}</p>}
/>
```

Выглядит как правило, а работает как механизм: меняется галочка — Active решает; нажали submit — Active пересчитывается; отметили touched — Active пересчитывается. И всё это без ручных `useState`-флагов вокруг ошибки.

---

## Мини-итог

Active — это про контроль над жизнью DOM: ты ставишь реактивный “шлагбаум” там, где React чаще всего делает больно (модалки, сцены, условные узлы, ошибки форм), и перестаёшь лечить симптомы мемоизацией. `sg` даёт состояние, `is` даёт правило, `triggers` — дополнительные поводы пересчитать, а `ch={() => ...}` делает это чисто и без лишней суеты.
